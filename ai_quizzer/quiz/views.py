import google.generativeai as genai
from django.core.cache import cache
from django.contrib.auth import authenticate
from rest_framework.permissions import IsAuthenticated
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework_simplejwt.tokens import RefreshToken
from .models import Quiz, Submission
from .serializers import QuizSerializer, SubmissionSerializer
from django.contrib.auth.models import User
from rest_framework import serializers

# Load the Google Gemini API Key
API_KEY = "AIzaSyCCcJmYIuN2B-slsFcYEheF3CgUEPNVBtg"
genai.configure(api_key=API_KEY)

# Register View - User Sign Up
class UserSerializer(serializers.ModelSerializer):
    password = serializers.CharField(write_only=True)

    class Meta:
        model = User
        fields = ['username', 'password']

    def create(self, validated_data):
        user = User.objects.create_user(
            username=validated_data['username'],
            password=validated_data['password']
        )
        return user

class RegisterView(APIView):
    def post(self, request):
        serializer = UserSerializer(data=request.data)
        if serializer.is_valid():
            user = serializer.save()
            return Response({"message": "User created successfully", "username": user.username})
        return Response(serializer.errors, status=400)

# Login View - JWT Token Generation
class LoginView(APIView):
    def post(self, request):
        username = request.data.get('username')
        password = request.data.get('password')

        if not username or not password:
            return Response({"error": "Username and password are required"}, status=400)

        user = authenticate(username=username, password=password)
        if user:
            refresh = RefreshToken.for_user(user)
            return Response({
                "token": str(refresh.access_token),
                "refresh": str(refresh)
            })
        return Response({"error": "Invalid credentials"}, status=401)

# Generate Question using Google Gemini
def generate_question_with_choices(prompt):
    try:
        model = genai.GenerativeModel("gemini-1.5-flash")
        response = model.generate_content(prompt)
        question_text = response.text.strip()
        return {"question_text": question_text}
    except Exception as e:
        print(f"Error generating question: {e}")
        return None

# Create Quiz View - Admin/Authenticated User can create quizzes
class CreateQuizView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        serializer = QuizSerializer(data=request.data)
        if serializer.is_valid():
            quiz = serializer.save()

            # Cache the quiz after creation
            cache.set(f'quiz_{quiz.id}', quiz, timeout=3600)  # Cache for 1 hour
            
            # Generate questions dynamically
            questions = []
            for _ in range(5):  # Generate 5 questions as an example
                prompt = f"Generate a completely unique distinct general knowledge question for the subject '{quiz.subject}', ensuring that the question is distinct and unrelated to every other questions generated by you. Each question should have four distinct options: Option 1, Option 2, Option 3, and Option 4. Provide each option on a new line and, at the end, specify the correct option in the last line as the answer. Make sure that the questions and choices are varied and do not repeat or resemble previous questions. Maintain Uniqueness in questions and choices is must."                
                question = generate_question_with_choices(prompt)
                if question:
                    questions.append(question)

            quiz.question_data = questions
            quiz.save()

            return Response({"message": "Quiz created successfully", "quiz": serializer.data})
        return Response(serializer.errors, status=400)

# Submit Quiz View - User submits answers to a quiz
class SubmitQuizView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        quiz_id = request.data.get('quiz_id')
        try:
            quiz = Quiz.objects.get(id=quiz_id)
        except Quiz.DoesNotExist:
            return Response({"error": "Quiz not found"}, status=404)

        answers = request.data.get('answers')
        if not isinstance(answers, list) or len(answers) != len(quiz.question_data):
            return Response({"error": "Answers should match the number of questions."}, status=400)

        score = self.evaluate_quiz(quiz, answers)

        # Save the submission with the score
        submission = Submission.objects.create(
            quiz=quiz,
            student_name=request.user.username,
            answers=answers,
            score=score
        )

        return Response({"score": score, "result": "pass" if score >= 50 else "fail", "submission_id": submission.id})

    @staticmethod
    def evaluate_quiz(quiz, answers):
        score = 0
        for question, user_answer in zip(quiz.question_data, answers):
            if question["answer"] == user_answer:
                score += 10
        return score

# Generate Question View - Generates a question based on user input
class GenerateQuestionView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        text = request.data.get('text')
        if not text:
            return Response({"error": "Text parameter is required."}, status=400)

        question = generate_question_with_choices(text)
        if question:
            return Response({"generated_question": question})
        return Response({"error": "Failed to generate question."}, status=500)

# Generate Hint View - Generates a hint based on user input question
class GenerateHintView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        question_text = request.data.get('question_text')
        
        # Validate input data
        if not question_text:
            return Response({"error": "Question text is required."}, status=400)

        # Call the function to generate a hint
        hint = generate_hint_with_ai(question_text)
        
        # Check if a hint was generated and return the appropriate response
        if hint:
            return Response({"hint": hint})
        return Response({"error": "Failed to generate hint."}, status=500)

def generate_hint_with_ai(question_text):
    try:
        # Use Google Gemini to generate a hint based on the question text
        model = genai.GenerativeModel("gemini-1.5-flash")
        prompt = f"Provide a hint for the following question: {question_text}"
        
        # Make the request to Gemini for content generation
        response = model.generate_content(prompt)
        
        # Return the generated hint text
        return response.text.strip()
    
    except Exception as e:
        print(f"Error generating hint: {e}")
        return None

# Submission History View - Retrieve quiz history based on filters
class SubmissionHistoryView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        grade = request.query_params.get('grade')
        subject = request.query_params.get('subject')
        from_date = request.query_params.get('from')
        to_date = request.query_params.get('to')

        submissions = Submission.objects.all()

        if grade:
            submissions = submissions.filter(quiz__grade_level=grade)
        if subject:
            submissions = submissions.filter(quiz__subject=subject)
        if from_date and to_date:
            submissions = submissions.filter(created_at__range=[from_date, to_date])

        serializer = SubmissionSerializer(submissions, many=True)
        return Response(serializer.data)

# Retry Quiz View - Allows the user to retry a quiz and re-evaluate the score
class RetryQuizView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        quiz_id = request.data.get('quiz_id')
        try:
            quiz = Quiz.objects.get(id=quiz_id)
        except Quiz.DoesNotExist:
            return Response({"error": "Quiz not found"}, status=404)

        answers = request.data.get('answers')
        score = SubmitQuizView.evaluate_quiz(quiz, answers)

        submission = Submission.objects.create(
            quiz=quiz,
            student_name=request.user.username,
            answers=answers,
            score=score
        )

        return Response({"score": score, "result": "pass" if score >= 50 else "fail", "submission_id": submission.id})